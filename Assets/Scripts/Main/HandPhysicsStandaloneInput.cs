using UnityEngine;
using System;
using System.Diagnostics;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Threading;

namespace HandPhysicsExtenstions
{
    [RequireComponent(typeof(HandPhysicsController))]
    public class HandPhysicsStandaloneInput : MonoBehaviour
    {
        public HandPhysicsController Controller;
        public GameObject cube;
        public GameObject hand;
        public int speed = 10;

        public bool LockCursor = true;
        public bool ControlsEnabled = true;
        public bool drawCurve = false;

        private string filename = "D:\\Projects\\UNITY_PROJECT\\Mr.dou-and-Mrs.dou\\Assets\\Scripts\\Main\\modbus.py";
        private string cmd = "\"Form C#:\"";
        private Process process;

        private MemoryMappedFile ShareMemory;
        private MemoryMappedViewAccessor viewAccessor;
        private int[] command = new int[8];

        private Vector3 handPosition;
        private Vector3 endPosition;
        private Vector3 palmPosition;
        private Transform transform;
        Vector3 travec;
        Boolean flag = true;
        Boolean grap = false;
        Boolean grapback = false;
        float step ;

        [Header("Input Keys")]
        public string MoveForearmAxisX = "Mouse X";
        public string MoveForearmAxisY = "Mouse ScrollWheel";
        public string MoveForearmAxisZ = "Mouse Y";

        [Space]
        public string RotateForearmAxis = "Mouse X";
        public string RotateWristAxis = "Mouse Y";

        [Space]
        public KeyCode HoldRotation = KeyCode.Mouse1;

        public void OnApplicationFocus(bool focus)
        {
            if (focus && LockCursor)
                Cursor.lockState = CursorLockMode.Locked;
        }

        void Start()
        {
            grap = false;
            transform = hand.GetComponent<Transform>();
            handPosition = transform.position;//手初始坐标
            print("handPosition:  " + handPosition);

            palmPosition = new Vector3(handPosition.x, handPosition.y, (handPosition.z + 7.8f * 0.2f));
            print("palmPosition:  " + palmPosition);

            endPosition = cube.GetComponent<Transform>().position;
            print("yuanzhu:  "+endPosition);

            endPosition = new Vector3(endPosition.x, 0.5f, endPosition.z);
            print("mubiaoweizhi:  "+endPosition);

            travec = endPosition - palmPosition;
            //Vector3 travec = new Vector3(-1.5f,0.0f,0.3f);
            print("yidongxiangliang:  "+ travec);
            step = speed * Time.deltaTime;
            

            //Controller.MoveForearm(travec);

            if (drawCurve)
            {
                filename.Replace("modbus.py", "modbus_curve.py");
            }

            long capacity = 1024;
            //创建或者打开共享内存  
            ShareMemory = MemoryMappedFile.CreateOrOpen("ShareMemory", capacity, MemoryMappedFileAccess.ReadWrite);
           
            //通过MemoryMappedFile的CreateViewAccssor方法获得共享内存的访问器  
             viewAccessor = ShareMemory.CreateViewAccessor(0, capacity);

            string input = "00000000";
            //向共享内存开始位置写入字符串的长度  
            //viewAccessor.Write(0, input.Length);

            //向共享内存4位置写入字符  
            viewAccessor.WriteArray<char>(0, input.ToArray(), 0, input.Length);

            string cmd1 = string.Format("{0} {1}", filename, cmd);
            run_cmd("python.exe", cmd1);//运行Python脚本
        }

        public void run_cmd(string program, string cmd)
        {
            ProcessStartInfo start = new System.Diagnostics.ProcessStartInfo();
            start.FileName = program;
            start.Arguments = cmd;
            start.UseShellExecute = false;          // Do not use OS shell
            start.CreateNoWindow = true;            // We don't need new window
            start.RedirectStandardOutput = false;    // Any output, generated by application will be redirected back
            start.RedirectStandardError = true;     // Any error in standard output will be redirected back (for example exceptions)
            process = Process.Start(start);
        }

        void OnApplicationQuit()
        {
            process.Dispose();
            ShareMemory.Dispose();
            Process.GetProcessesByName("python")[0].Kill(); 
        }

        

        void Update()
        {
            //print(Controller.Parts.Forearm.transform.position);
            //读取字节------------------这里有一个大坑：Python写内存是按字节写入的，所以读内存的时候一定要按字节读出，否则不正确
            String com = "";
            for(int i = 0;i<5;i++)
            {
                command[i] = viewAccessor.ReadByte(i) - '0';
                
                com += command[i].ToString();
            }
            //print(com);

            if (!ControlsEnabled )
                return;

            if (command[1] == 1)
            {
                grap = true;
            }

            if (grap)
            {

                //Controller.MoveForearm(new Vector3(-0.5f, -0.1f, 0.55f));
                Controller.Parts.Forearm.transform.position = Vector3.MoveTowards(Controller.Parts.Forearm.transform.position, new Vector3(-0.28f, 0.38f, -2.16f), step);
                //hand.transform.localPosition = new Vector3(
                //    Mathf.Lerp(hand.transform.localPosition.x, -0.2f, step),
                //    Mathf.Lerp(hand.transform.localPosition.y, 0.4f, step),
                //    Mathf.Lerp(hand.transform.localPosition.z, -2.1f, step));
            }
            if (Mathf.Approximately(Controller.Parts.Forearm.transform.position.y, 0.38f))
            {

                grap = false;
                Controller.StartBendFingers();
                grapback = true;
            }

            if (grapback)
            {
                Controller.Parts.Forearm.transform.position = Vector3.MoveTowards(Controller.Parts.Forearm.transform.position, new Vector3(-0.2f, 0.6f, -2.1f), step);
                Controller.RotateForearm(-160);
            }
            if (Mathf.Approximately(Controller.Parts.Forearm.transform.position.y, 0.6f))
            {
                grapback = false;
            }

            //if(Controller.Parts.Forearm.Joint.targetRotation == 90)

            //if(grap&&loop>200)
            //{
            //    grap = false;
            //    loop = 0;
            //    Controller.StartBendFingers();
            //if (command[0] == 1)
            //    Controller.StartBendFinger(FingerType.Thumb);
            //else if (command[0] == 2)
            //    Controller.StopBendFinger(FingerType.Thumb);

            //if (command[1] == 1)
            //    Controller.StartBendFinger(FingerType.Index);
            //else if (command[1] == 2)
            //    Controller.StopBendFinger(FingerType.Index);

            //if (command[2] == 1)
            //    Controller.StartBendFinger(FingerType.Middle);
            //else if (command[2] == 2)
            //    Controller.StopBendFinger(FingerType.Middle);

            //if (command[3] == 1)
            //    Controller.StartBendFinger(FingerType.Ring);
            //else if (command[3] == 2)
            //    Controller.StopBendFinger(FingerType.Ring);

            //if (command[4] == 1)
            //    Controller.StartBendFinger(FingerType.Pinky);
            //else if (command[4] == 2)
            //    Controller.StopBendFinger(FingerType.Pinky);
            //}
            //else
            //{

            //    loop++;
            //}


            if (!Input.GetKey(HoldRotation))
                Controller.MoveForearm(new Vector3(Input.GetAxis(MoveForearmAxisX), Input.GetAxis(MoveForearmAxisY),
                    Input.GetAxis(MoveForearmAxisZ)));
            else
            {
                Controller.RotateWrist(Input.GetAxis(RotateWristAxis));
                Controller.RotateForearm(Input.GetAxis(RotateForearmAxis));
            }
        }
    }
}

