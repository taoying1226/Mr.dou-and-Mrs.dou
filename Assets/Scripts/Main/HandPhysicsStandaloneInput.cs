using UnityEngine;
using System;
using System.Diagnostics;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Threading;

namespace HandPhysicsExtenstions
{
    [RequireComponent(typeof(HandPhysicsController))]
    public class HandPhysicsStandaloneInput : MonoBehaviour
    {
        public HandPhysicsController Controller;
        public GameObject GPS;
        public GameObject cube1;
        public GameObject cube2;
        public GameObject capsule;

        private GameObject pick_player;//要捡起的物体
        private Transform pick_player_transform;

        public float speed = 2.0f;

        public bool LockCursor = true;
        public bool ControlsEnabled = true;
        public bool drawCurve = false;
        public bool runWithPython = true;

        private string filename = "D:\\Projects\\UNITY_PROJECT\\EE5003_Update_20181101\\MscProj_20181025\\Assets\\Scripts\\Main\\SerialCommunication.py";
        private string cmd = "\"Form C#:\"";
        private Process process;

        private MemoryMappedFile ShareMemory;
        private MemoryMappedViewAccessor viewAccessor;
        private int[] command = new int[8];

        private Vector3 wristPosition;//手掌的位置
        private Vector3 playerPosition;//可捡起的物体的位置
        private Vector3 handTargetPosition;//手的目标位置
        private Vector3 handStartGrabPosition;//手开始抓时的位置
        private Transform GPS_transform;//在手心的一个小方块

        int grabStep = 0;
        float step;
        int updateTimes;
        float DetectionRadius = 0.55f;//手掌对物体的感应范围的半径

        struct TargetRotation
        {
            public float joint1;
            public float joint2;
            public float joint3;
        }

        private TargetRotation[] fingersTargetRotationBackUp = new TargetRotation[5];

        [Header("Input Keys")]
        public string MoveForearmAxisX = "Mouse X";
        public string MoveForearmAxisY = "Mouse ScrollWheel";
        public string MoveForearmAxisZ = "Mouse Y";

        [Space]
        public string RotateForearmAxis = "Mouse X";
        public string RotateWristAxis = "Mouse Y";

        [Space]
        public KeyCode HoldRotation = KeyCode.Mouse1;
        public KeyCode Grab = KeyCode.G;
        public KeyCode StopGrab = KeyCode.F;
        public KeyCode pickup = KeyCode.Space; 

        public void OnApplicationFocus(bool focus)
        {
            if (focus && LockCursor)
                Cursor.lockState = CursorLockMode.Locked;
        }

        void Start()
        {
            for(int i = 0;i<5;i++)
            {
                fingersTargetRotationBackUp[i].joint1 = Controller.Parts.Fingers[i].GetComponent<FingerPart>().TargetRotation.x;
                fingersTargetRotationBackUp[i].joint2 = Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[1].GetComponent<FingerPart>().TargetRotation.x;
                fingersTargetRotationBackUp[i].joint3 = Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[2].GetComponent<FingerPart>().TargetRotation.x;
            }

            grabStep = 0;
            updateTimes = 0;

            GPS_transform = GPS.GetComponent<Transform>();

            handTargetPosition = GPS_transform.position;
            handStartGrabPosition = Vector3.zero;

            step = speed * Time.deltaTime;

            long capacity = 1024;
            //创建或者打开共享内存  
            ShareMemory = MemoryMappedFile.CreateOrOpen("ShareMemory", capacity, MemoryMappedFileAccess.ReadWrite);
           
            //通过MemoryMappedFile的CreateViewAccssor方法获得共享内存的访问器  
             viewAccessor = ShareMemory.CreateViewAccessor(0, capacity);

            string cmd1 = string.Format("{0} {1}", filename, cmd);
            if(runWithPython)
            {
                run_cmd("python.exe", cmd1);//运行Python脚本
            }
        }

        public void run_cmd(string program, string cmd)
        {
            ProcessStartInfo start = new System.Diagnostics.ProcessStartInfo();
            start.FileName = program;
            start.Arguments = cmd;
            start.UseShellExecute = false;          // Do not use OS shell
            start.CreateNoWindow = true;            // We don't need new window
            start.RedirectStandardOutput = false;    // Any output, generated by application will be redirected back
            start.RedirectStandardError = true;     // Any error in standard output will be redirected back (for example exceptions)
            process = Process.Start(start);
        }

        void OnApplicationQuit()
        {
            ShareMemory.Dispose();
            if (runWithPython)
            {
                process.Dispose();
                Process.GetProcessesByName("python")[0].Kill();
            }
            
        }

        //void OnDrawGizmos()
        //{
        //    Gizmos.color = Color.red;
        //    Gizmos.DrawSphere(GPS.transform.position, 0.7f);
        //}

        void wait(int _updateTimes, int targetgrabStep)//等待Update()函数运行_updateTimes次后，将grabStep的值设为targetgrabStep
        {
            updateTimes ++;
            if (updateTimes == _updateTimes)
            {
                updateTimes = 0;
                grabStep = targetgrabStep;
            }
        }

        void StartBendFinger(int i, float joint1TargetRotation, float joint2TargetRotation, float joint3TargetRotation)//设定目标角度的手指弯曲
        {
            Controller.Parts.Fingers[i].GetComponent<FingerPart>().TargetRotation.x = joint1TargetRotation;

            Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[1].GetComponent<FingerPart>().TargetRotation.x = joint2TargetRotation;
            Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[2].GetComponent<FingerPart>().TargetRotation.x = joint3TargetRotation;

            switch (i)
            {
                case 0:
                    Controller.StartBendFinger(FingerType.Thumb);
                    break;
                case 1:
                    Controller.StartBendFinger(FingerType.Index);
                    break;
                case 2:
                    Controller.StartBendFinger(FingerType.Middle);
                    break;
                case 3:
                    Controller.StartBendFinger(FingerType.Ring);
                    break;
                case 4:
                    Controller.StartBendFinger(FingerType.Pinky);
                    break;
            }

        }

        void StopBendFinger(int i)//恢复初始目标角度，并伸直手指
        {
            //resetTargetRotation();
            switch (i)
            {
                case 0:
                    Controller.StopBendFinger(FingerType.Thumb);
                    break;
                case 1:
                    Controller.StopBendFinger(FingerType.Index);
                    break;
                case 2:
                    Controller.StopBendFinger(FingerType.Middle);
                    break;
                case 3:
                    Controller.StopBendFinger(FingerType.Ring);
                    break;
                case 4:
                    Controller.StopBendFinger(FingerType.Pinky);
                    break;
            }

        }

        void resetTargetRotation()//恢复所有手指弯曲的目标角度
        {
            for(int i = 0; i<5;i++)
            {
                Controller.Parts.Fingers[i].GetComponent<FingerPart>().TargetRotation.x = fingersTargetRotationBackUp[i].joint1;
                Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[1].GetComponent<FingerPart>().TargetRotation.x = fingersTargetRotationBackUp[i].joint2;
                Controller.Parts.Fingers[i].GetComponent<Finger>().Parts[2].GetComponent<FingerPart>().TargetRotation.x = fingersTargetRotationBackUp[i].joint3;
            }
        }

        void Update()
        {
            if (!ControlsEnabled)
                return;

            #region get the command
            //读取字节------------------这里有一个大坑：Python写内存是按字节写入的，所以读内存的时候一定要按字节读出，否则不正确
            String com = "";
            for (int i = 0; i <= 5; i++)
            {
                byte ReadByte = viewAccessor.ReadByte(i);
                command[i] = ReadByte - '0';
                //print(ReadByte);
                //print(command[i]);
                com += command[i].ToString();
            }
            print(com);
            #endregion

            #region grab objects
            //0:没有命令 --》按空格抓取 --》1：翻转将手心向下 --》2：伸手（把手运动到目标位置） --》 3：弯曲手指抓 --》4：把手收回来（收到按下空格时的位置）--》5：把手翻过 --》6：等待放下物体--》7：把手翻到0度（手心向下）--》8：松开手
            //print(Controller.Parts.Fingers[1].IsBending);

            //获取以坐标GPS_transform.position（手掌的中心）为圆心，以DetectionRadius为半径的球的范围内的Layer为‘player’的物体
            Collider[] cs = Physics.OverlapSphere(GPS_transform.position, DetectionRadius, 1 << LayerMask.NameToLayer("player"));
            if (cs.Length != 0 && grabStep == 0)
            {
                //print("cube1: " + cube1.GetComponent<Transform>().position + "cube2: " + cube2.GetComponent<Transform>().position + "capsule: " + capsule.GetComponent<Transform>().position);
                handStartGrabPosition = Controller.Parts.Forearm.transform.position;
                handTargetPosition = Vector3.zero;
                if (pick_player)//把上一个被检测成红色的物体转换为蓝色
                {
                    pick_player.GetComponent<MeshRenderer>().material.color = Color.blue;
                }
                pick_player = cs[0].gameObject;
                //print("pick_player: " + pick_player.name);

                pick_player.GetComponent<Rigidbody>().useGravity = false;

                pick_player_transform = pick_player.GetComponent<Transform>();
                pick_player.GetComponent<MeshRenderer>().material.color = Color.red;

                Vector3 tra_vec = pick_player_transform.position - GPS_transform.position;

                //print(handTargetPosition);

                handTargetPosition = new Vector3(
                    Controller.Parts.Forearm.transform.position.x + tra_vec.x,
                    Controller.Parts.Forearm.transform.position.y + tra_vec.y + pick_player_transform.position.y,
                    Controller.Parts.Forearm.transform.position.z + tra_vec.z);

                //print(
                //    "pick_player_name: " + pick_player.name +
                //    "  Forearm.transform: " + Controller.Parts.Forearm.transform.position +
                //    "  GPS_transform: " + GPS_transform.position +
                //    "  pick_player: " + pick_player_transform.position +
                //    "  tra_vec: " + tra_vec +
                //    "  handTargetPosition: " + handTargetPosition);

            }
            else if(grabStep == 0)//没有检测到物体，状态为0,（没有发出命令）
            {
                if(pick_player)
                {
                    pick_player.GetComponent<MeshRenderer>().material.color = Color.blue;
                }
                pick_player = null;
            }

            if (Input.GetKey(pickup) && grabStep == 0 && pick_player)//按空格
            {
                resetTargetRotation();
                grabStep = 1;
            }

            if(grabStep == 1)
            {
                Controller.RotateForearmTo(0);//先将手转到0度，手心向下为0度
                wait(15, 2);
            }

            if (grabStep == 2 )//伸手去抓
            {
                Controller.Parts.Forearm.transform.position = Vector3.MoveTowards(Controller.Parts.Forearm.transform.position, handTargetPosition, step);
                if (Mathf.Approximately(Controller.Parts.Forearm.transform.position.y, handTargetPosition.y))
                {
                    grabStep = 3;
                    Controller.StartBendFingers();
                }
            }

            if(grabStep == 3)//抓
            {
                wait(30, 4);//等待一段时间后再转到状态3
            }

            if (grabStep == 4)//收回手
            {
                Controller.Parts.Forearm.transform.position = Vector3.MoveTowards(Controller.Parts.Forearm.transform.position, handStartGrabPosition, step);
                if (Mathf.Approximately(Controller.Parts.Forearm.transform.position.y, handStartGrabPosition.y))
                {
                    grabStep = 5;
                }
            }

            if (grabStep == 5)//翻手
            {
                Controller.RotateForearm(-160);
                wait(30, 6);//等待一段时间后，转到状态6
            }

            if (Input.GetKey(pickup) && grabStep == 6)
            {
                grabStep = 7;//如果再次按下空格键，则转到状态7,
            }

            if (grabStep == 7)
            {
                Controller.RotateForearmTo(0);//状态7进行翻手，翻到0度，掌心向下为0度
                wait(30, 8);

            }

            if (grabStep == 8)
            {
                Controller.StopBendFingers();//翻手之后，松开物体
                wait(30, 0);
            }

            if (Input.GetKey(Grab))//按‘G’抓
            {
                grabStep = 99;
                resetTargetRotation();
                Controller.StartBendFingers();
            }

            if (Input.GetKey(StopGrab))//按‘F’松开
            {
                grabStep = 0;
                Controller.StopBendFingers();
            }
            #endregion


            #region gestures 
            if (Input.GetKey(KeyCode.Alpha1))
            {
                grabStep = 99; 
                resetTargetRotation();
                Controller.StartBendFinger(FingerType.Middle);
                Controller.StartBendFinger(FingerType.Ring);
                Controller.StartBendFinger(FingerType.Pinky);
            }

            if (Input.GetKey(KeyCode.Alpha2))
            {
                grabStep = 99;
                resetTargetRotation();
                Controller.StartBendFinger(FingerType.Ring);
                Controller.StartBendFinger(FingerType.Pinky);
            }

            if (Input.GetKey(KeyCode.Alpha3))
            {
                grabStep = 99;
                resetTargetRotation();
                Controller.StartBendFinger(FingerType.Index);
            }

            #endregion


            if(Input.GetKey(KeyCode.Q))
            {
                grabStep = 99;
                StartBendFinger(1, 0.0f, 0.3f, 0.5f);
            }

            if (Input.GetKey(KeyCode.E))
            {
                grabStep = 99;
                StartBendFinger(1, 0.0f, 0.8f, 0.5f);
            }

            //if (Input.GetKey(KeyCode.Y))
            //{
                
            //    Controller.RotateWristTo(45);
            //}

            #region controll by command
            if (grabStep == 0)
            {

                if (command[0] == 1)
                {
                    StartBendFinger(0, 0.0f, 0.0f, 0.3f);//i指的是第i个手指，后边三个浮点数参数为每个关节的弯曲程度，1是最大弯曲
                }
                else if (command[0] == 2)
                {
                    StartBendFinger(0, 0.0f, 0.0f, 0.9f);
                }
                else if (command[0] == 0)
                {
                    StopBendFinger(0);
                }

                for (int i = 1; i < 5; i++)
                {
                    //command[i]为1,2,3分别为三种弯曲程度
                    if (command[i] == 1)
                    {
                        StartBendFinger(i, 0.0f, 0.3f, 0.5f);//i指的是第i个手指，后边三个浮点数参数为每个关节的弯曲程度，1是最大弯曲
                    }
                    else if (command[i] == 2)
                    {
                        StartBendFinger(i, 0.0f, 0.6f, 0.5f);
                    }
                    else if (command[i] == 3)
                    {
                        StartBendFinger(i, 0.0f, 0.9f, 0.5f);
                    }
                    else if (command[i] == 0)
                    {
                        StopBendFinger(i);
                    }
                }

                if(command[5] == 1)//用command[5]控制手腕弯曲的角度
                {
                    Controller.RotateWristTo(25);//控制手腕弯曲的角度：25度
                }
                else if (command[5] == 2)
                {
                    Controller.RotateWristTo(45);
                }
                else if(command[5] == 0)
                {
                    Controller.RotateWristTo(0);
                }
            }
            #endregion


            if (!Input.GetKey(HoldRotation))
            {
                Controller.MoveForearm(new Vector3(Input.GetAxis(MoveForearmAxisX), Input.GetAxis(MoveForearmAxisY),
                  Input.GetAxis(MoveForearmAxisZ)));
            }
            else
            {
                Controller.RotateWrist(Input.GetAxis(RotateWristAxis));
                Controller.RotateForearm(Input.GetAxis(RotateForearmAxis));
            }
        }
    }
}

